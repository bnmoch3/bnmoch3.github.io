<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://bnmoch3.org/favicon.ico?><link rel=icon type=image/png sizes=16x16 href=https://bnmoch3.org/favicon-16x16.png?><link rel=icon type=image/png sizes=32x32 href=https://bnmoch3.org/favicon-32x32.png?><link rel=icon type=image/png sizes=192x192 href=https://bnmoch3.org/android-chrome-192x192.png?><link rel=apple-touch-icon sizes=180x180 href=https://bnmoch3.org/apple-touch-icon.png?><meta name=description content><title>Timeseries and ASOF Joins | bnmoch3
</title><link rel=canonical href=https://bnmoch3.org/p/sql-asof-joins/><meta property="og:url" content="https://bnmoch3.org/p/sql-asof-joins/"><meta property="og:site_name" content="bnmoch3"><meta property="og:title" content="Timeseries and ASOF Joins"><meta property="og:description" content="Pairing up timeseries data when the timestamps don’t match exactly (in Pandas, Polars, DuckDB, Postgres & QuestDB)"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-29T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-29T00:00:00+00:00"><meta property="article:tag" content="Timeseries"><meta property="article:tag" content="SQL"><meta property="article:tag" content="Python"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="DuckDB"><link rel=stylesheet href=/assets/combined.min.01980ad4202828eb32272e7b1654f79f3c0022c15b1c932668dff73dffaf7e88.css media=all></head><body class=light><div class=content><header><div class=header><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/about>/about</a></p><p class=small><a href=/posts>/posts</a></p><p class=small><a href=/notes>/notes</a></p><p class=small><a href=/tags>/tags</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/posts/>Posts</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/p/sql-asof-joins/>Timeseries and ASOF Joins</a></div><div><div class=single-intro-container><h1 class=single-title>Timeseries and ASOF Joins</h1><p class=single-readtime><time datetime=2024-11-29T00:00:00+00:00>November 29, 2024</time>
&nbsp; · &nbsp;
12 min read</p></div><div class=single-tags><span><a href=https://bnmoch3.org/tags/timeseries/>#Timeseries</a>
</span><span><a href=https://bnmoch3.org/tags/sql/>#SQL</a>
</span><span><a href=https://bnmoch3.org/tags/python/>#Python</a>
</span><span><a href=https://bnmoch3.org/tags/postgresql/>#PostgreSQL</a>
</span><span><a href=https://bnmoch3.org/tags/duckdb/>#DuckDB</a></span></div><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#overview>Overview</a></li><li><a href=#setting-up-the-data>Setting up the data</a></li><li><a href=#duckdb>DuckDB</a></li><li><a href=#pandas>Pandas</a></li><li><a href=#polars>Polars</a></li><li><a href=#questdb>QuestDB</a></li><li><a href=#postgresql>PostgreSQL</a></li><li><a href=#notable-mentions>Notable mentions</a></li><li><a href=#referencesfurther-reading>References/Further Reading</a></li></ul></nav></aside><div class=single-content><h2 class=heading id=overview>Overview
<a href=#overview>#</a></h2><p>An ASOF join is a kind of join that matches rows from one table with the
<em>closest</em> row from another table per a given column (usually timestamps or date
values). It&rsquo;s necessary since related events might not happen exactly at the
same time or be recorded with the same timestamp (different clocks used), or
even sampled at the same rate. But in order to get full context, we need to pair
them up for further upstream processing and analysis.</p><p>For example, metrics might be scraped at a given rate but the logs being
generated are more bursty and dependent on external events. We might then want
to pair up a log entry with the closest metrics for that node that were captured
right before the log was emitted.</p><p>The most common form of asof joins is the left outer variety whereby only rows
that are less than or equal to a given row on the right are considered. To
phrase it differently, match an event on the left with one on the right that
happened either exactly at the same time or just before. If we don&rsquo;t get a
match, we fill in NULLS (left join).</p><p>This post is partly an overview of how different databases/libraries present
asof joins, and also a tour of importing Apache Arrow-based data into these
systems (from zero-copy to good old-fashioned CSV).</p><h2 class=heading id=setting-up-the-data>Setting up the data
<a href=#setting-up-the-data>#</a></h2><p>Alright, let&rsquo;s start with some data to play around with. This demo data is
sourced from
<a href=https://questdb.io/docs/reference/sql/join/#asof-join>QuestDB&rsquo;s documentation</a>,
specifically the section on asof joins. It consists of bids and asks for a
single instrument (just to keep things simple).</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bids <span style=color:#666>=</span> [
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.000000Z&#34;</span>, <span style=color:#40a070>100</span>),
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.100000Z&#34;</span>, <span style=color:#40a070>101</span>),
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.300000Z&#34;</span>, <span style=color:#40a070>102</span>),
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.500000Z&#34;</span>, <span style=color:#40a070>103</span>),
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.600000Z&#34;</span>, <span style=color:#40a070>104</span>),
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asks <span style=color:#666>=</span> [
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.100000Z&#34;</span>, <span style=color:#40a070>100</span>),
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.300000Z&#34;</span>, <span style=color:#40a070>101</span>),
</span></span><span style=display:flex><span>    (<span style=color:#4070a0>&#34;2019-10-17T00:00:00.400000Z&#34;</span>, <span style=color:#40a070>102</span>),
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Next, let&rsquo;s convert the lists into Arrow Tables since it makes it easier to
interface with most of systems I&rsquo;ll be using to run asof joins.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>datetime</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>dt</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>pyarrow</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>pa</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>schema <span style=color:#666>=</span> pa<span style=color:#666>.</span>schema(
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        pa<span style=color:#666>.</span>field(<span style=color:#4070a0>&#34;ts&#34;</span>, pa<span style=color:#666>.</span>timestamp(<span style=color:#4070a0>&#34;us&#34;</span>, tz<span style=color:#666>=</span><span style=color:#4070a0>&#34;UTC&#34;</span>), nullable<span style=color:#666>=</span><span style=color:#007020;font-weight:700>False</span>),
</span></span><span style=display:flex><span>        pa<span style=color:#666>.</span>field(<span style=color:#4070a0>&#34;size&#34;</span>, pa<span style=color:#666>.</span>uint64(), nullable<span style=color:#666>=</span><span style=color:#007020;font-weight:700>False</span>),
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>to_batch <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>lambda</span> entries, schema: pa<span style=color:#666>.</span>record_batch(
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        pa<span style=color:#666>.</span>array((t[i] <span style=color:#007020;font-weight:700>for</span> t <span style=color:#007020;font-weight:700>in</span> entries), <span style=color:#007020>type</span><span style=color:#666>=</span>t)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>for</span> i, t <span style=color:#007020;font-weight:700>in</span> <span style=color:#007020>enumerate</span>(schema<span style=color:#666>.</span>types)
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    schema<span style=color:#666>=</span>schema,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>to_arrow_table <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>lambda</span> entries, schema: pa<span style=color:#666>.</span>Table<span style=color:#666>.</span>from_batches(
</span></span><span style=display:flex><span>    [to_batch(entries, schema)]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parse_ts <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>lambda</span> ts: dt<span style=color:#666>.</span>datetime<span style=color:#666>.</span>strptime(ts, <span style=color:#4070a0>&#34;%Y-%m-</span><span style=color:#70a0d0>%d</span><span style=color:#4070a0>T%H:%M:%S.</span><span style=color:#70a0d0>%f</span><span style=color:#4070a0>Z&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>with_timestamps_parsed <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>lambda</span> rows: ((parse_ts(ts), n) <span style=color:#007020;font-weight:700>for</span> (ts, n) <span style=color:#007020;font-weight:700>in</span> rows)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asks <span style=color:#666>=</span> to_arrow_table(<span style=color:#007020>list</span>(with_timestamps_parsed(asks)), schema)
</span></span><span style=display:flex><span>bids <span style=color:#666>=</span> to_arrow_table(<span style=color:#007020>list</span>(with_timestamps_parsed(bids)), schema)
</span></span></code></pre></div><p>A couple of details worth noting:</p><ul><li>the generator objects have to be list-ified before being passed to
<code>to_arrow_table</code> since they&rsquo;ll be be iterated over several times for each
column.</li><li>the timestamps are in <a href=https://en.wikipedia.org/wiki/ISO_8601>ISO 8601</a>
format with a fractional component for the seconds and timezone data (the Z
means its UTC i.e. Zero offset from UTC)</li><li>Python&rsquo;s <code>dt.datetime.strptime</code> seems to discard the timezone info. Not a big
issue in this case, yet.</li><li>It would have been more efficient to parse the timestamp strings using
<a href=https://arrow.apache.org/docs/python/generated/pyarrow.compute.strptime.html><code>pyarrow.compute.strptime</code></a>
but it doesn&rsquo;t support fractional seconds. Check this
<a href=https://github.com/apache/arrow/issues/20146>github issue</a> for more details.</li></ul><p>With the data all set up, let&rsquo;s do some querying:</p><h2 class=heading id=duckdb>DuckDB
<a href=#duckdb>#</a></h2><p>Querying an Arrow table from DuckDB is quite easy: as long as the table is in
scope, DuckDB&rsquo;s Python client will pick it up automatically. Just to be a bit
little fancy, I&rsquo;ve added the Arrow tables as views.</p><pre tabindex=0><code>import duckdb

duckdb.sql(
    &#34;&#34;&#34;
    create view asks as select ts at time zone &#39;UTC&#39; as ts, size from asks_tbl;
    create view bids as select ts at time zone &#39;UTC&#39; as ts, size from bids_tbl;
    &#34;&#34;&#34;
)
duckdb.sql(
    &#34;&#34;&#34;
    select
        b.ts as ts_bid,
        a.ts as ts_ask,
        b.size as bid,
        a.size as ask
    from bids b
    asof left join asks a on b.ts &gt;= a.ts
    order by ts_bid asc
    &#34;&#34;&#34;
).show()
</code></pre><p>As expected, this outputs:</p><pre tabindex=0><code>┌───────────────────────┬───────────────────────┬────────┬────────┐
│        ts_bid         │        ts_ask         │  bid   │  ask   │
│       timestamp       │       timestamp       │ uint64 │ uint64 │
├───────────────────────┼───────────────────────┼────────┼────────┤
│ 2019-10-17 00:00:00   │ NULL                  │    100 │   NULL │
│ 2019-10-17 00:00:00.1 │ 2019-10-17 00:00:00.1 │    101 │    100 │
│ 2019-10-17 00:00:00.3 │ 2019-10-17 00:00:00.3 │    102 │    101 │
│ 2019-10-17 00:00:00.5 │ 2019-10-17 00:00:00.4 │    103 │    102 │
│ 2019-10-17 00:00:00.6 │ 2019-10-17 00:00:00.4 │    104 │    102 │
└───────────────────────┴───────────────────────┴────────┴────────┘
</code></pre><p>Since I borrowed the data and query from QuestDB, I&rsquo;ll also add the explanation
they included in their
<a href=https://questdb.io/docs/reference/sql/join/#asof-join>docs</a>:</p><blockquote><p>The result has all rows from the bids table joined with rows from the asks
table. For each timestamp from the bids table, the query looks for a timestamp
that is equal or prior to it from the asks table. If no matching timestamp is
found, NULL is inserted.</p></blockquote><p>For this section, I&rsquo;m including both the <code>ts_bid</code> and <code>ts_ask</code> columns so that
you see that not all matches are &rsquo;exact&rsquo;. For later examples the <code>ts_ask</code> column
is dropped.</p><h2 class=heading id=pandas>Pandas
<a href=#pandas>#</a></h2><p>It seems a lot of folks in the financial field favour dataframe-based
data-analysis over SQL. And Pandas, being one of the most used dataframe
library, does provide Asof joins via the <code>merge_asof</code> function:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>pandas</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>pd</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asks_df <span style=color:#666>=</span> asks_tbl<span style=color:#666>.</span>to_pandas()
</span></span><span style=display:flex><span>bids_df <span style=color:#666>=</span> bids_tbl<span style=color:#666>.</span>to_pandas()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>res <span style=color:#666>=</span> pd<span style=color:#666>.</span>merge_asof(
</span></span><span style=display:flex><span>    bids_df,
</span></span><span style=display:flex><span>    asks_df,
</span></span><span style=display:flex><span>    on<span style=color:#666>=</span><span style=color:#4070a0>&#34;ts&#34;</span>,
</span></span><span style=display:flex><span>    direction<span style=color:#666>=</span><span style=color:#4070a0>&#34;backward&#34;</span>,
</span></span><span style=display:flex><span>    tolerance<span style=color:#666>=</span>pd<span style=color:#666>.</span>Timedelta(<span style=color:#4070a0>&#34;1s&#34;</span>),
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#007020>print</span>(res)
</span></span></code></pre></div><p>This prints:</p><pre tabindex=0><code>                                ts  size_x  size_y
0        2019-10-17 00:00:00+00:00     100     NaN
1 2019-10-17 00:00:00.100000+00:00     101   100.0
2 2019-10-17 00:00:00.300000+00:00     102   101.0
3 2019-10-17 00:00:00.500000+00:00     103   102.0
4 2019-10-17 00:00:00.600000+00:00     104   102.0
</code></pre><p>A couple of details worth pointing out:</p><ul><li>Converting an Arrow table into a pandas dataframe is rather straight-forward.
However, there are a couple of peculiarities to keep in mind given the data
representation that Pandas uses. See
<a href=https://arrow.apache.org/docs/python/pandas.html>the Pandas Integration section</a>
of the pyarrow docs.</li><li>The timestamp fields must be sorted prior to <code>merge_asof</code></li><li>Pandas allows not just for &ldquo;backwards&rdquo; direction when getting the closest
matches, but also for &ldquo;forward&rdquo; and &ldquo;nearest&rdquo; (closest absolute distance
regardless of direction) directions.</li><li>Pandas allows for tolerance (max range beyond which matches are left out). For
example, if we set the tolerance to 1 millisecond (<code>pd.Timedelta("1ms")</code>),
only the 2nd and third bids are paired with an ask:</li></ul><pre tabindex=0><code>                                ts  size_x  size_y
0        2019-10-17 00:00:00+00:00     100     NaN
1 2019-10-17 00:00:00.100000+00:00     101   100.0
2 2019-10-17 00:00:00.300000+00:00     102   101.0
3 2019-10-17 00:00:00.500000+00:00     103     NaN
4 2019-10-17 00:00:00.600000+00:00     104     NaN
</code></pre><h2 class=heading id=polars>Polars
<a href=#polars>#</a></h2><p>Polars is meant to be a faster alternative to Pandas (with IMO, a saner API). So
naturally, it too provides Asof joins:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>polars</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>pl</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asks_df <span style=color:#666>=</span> pl<span style=color:#666>.</span>from_arrow(asks_tbl)<span style=color:#666>.</span>set_sorted(<span style=color:#4070a0>&#34;ts&#34;</span>)
</span></span><span style=display:flex><span>bids_df <span style=color:#666>=</span> pl<span style=color:#666>.</span>from_arrow(bids_tbl)<span style=color:#666>.</span>set_sorted(<span style=color:#4070a0>&#34;ts&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>res <span style=color:#666>=</span> bids_df<span style=color:#666>.</span>join_asof(
</span></span><span style=display:flex><span>    asks_df,
</span></span><span style=display:flex><span>    on<span style=color:#666>=</span><span style=color:#4070a0>&#34;ts&#34;</span>,
</span></span><span style=display:flex><span>    strategy<span style=color:#666>=</span><span style=color:#4070a0>&#34;backward&#34;</span>,
</span></span><span style=display:flex><span>    tolerance<span style=color:#666>=</span><span style=color:#4070a0>&#34;1s&#34;</span>,
</span></span><span style=display:flex><span>)<span style=color:#666>.</span>rename({<span style=color:#4070a0>&#34;size&#34;</span>: <span style=color:#4070a0>&#34;bid&#34;</span>, <span style=color:#4070a0>&#34;size_right&#34;</span>: <span style=color:#4070a0>&#34;ask&#34;</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020>print</span>(res)
</span></span></code></pre></div><p>This outputs:</p><pre tabindex=0><code>shape: (5, 3)
┌─────────────────────────────┬─────┬──────┐
│ ts                          ┆ bid ┆ ask  │
│ ---                         ┆ --- ┆ ---  │
│ datetime[μs, UTC]           ┆ u64 ┆ u64  │
╞═════════════════════════════╪═════╪══════╡
│ 2019-10-17 00:00:00 UTC     ┆ 100 ┆ null │
│ 2019-10-17 00:00:00.100 UTC ┆ 101 ┆ 100  │
│ 2019-10-17 00:00:00.300 UTC ┆ 102 ┆ 101  │
│ 2019-10-17 00:00:00.500 UTC ┆ 103 ┆ 102  │
│ 2019-10-17 00:00:00.600 UTC ┆ 104 ┆ 102  │
└─────────────────────────────┴─────┴──────┘
</code></pre><p>With regards to Polars:</p><ul><li>We have to indicate that the dataframes are sorted plus the column by which
they are sorted (or sort them if they weren&rsquo;t). Otherwise Polars won&rsquo;t perform
the asof join.</li><li>Just like with Pandas, we can specify the strategy/direction and tolerance</li><li>There are additional knobs for parallel query execution</li><li>Arrow to Polars is zero-copy (for almost all data-types).</li><li>As an aside, DuckDB provides direct and zero-copy output to Polars dataframes
so we can use the view set up earlier to create dataframes. For details, see
<a href=https://duckdb.org/docs/guides/python/polars>this section</a> of the DuckDB
docs.</li></ul><h2 class=heading id=questdb>QuestDB
<a href=#questdb>#</a></h2><p>Back to QuestDB since this is where I first learned of ASOF joins. QuestDB is a
&lsquo;Columnar time-series database with high performance ingestion and SQL
analytics&rsquo;. More details can be found on its
<a href=https://questdb.io/>product page</a>.</p><p>So far, while everything has been within the same process, interaction with
QuestDB has to be over a network.</p><p>QuestDB supports various formats for ingesting data but its mostly optimized
for, (in terms of speed and convenience), &rsquo;live&rsquo; tuple/row/event ingestion vs.
data-warehouse style bulk ingestion. I thought it would have a means for
ingesting Arrow record batches by now since iirc I saw some of their lead devs
discussing it but as of version 7.2, it only supports CSV. It&rsquo;s worth pointing
out that CSV is fraught with problems, it&rsquo;s easy to generate and easy to inspect
and modify via simple string manipulation, any text editor and CLI tools, but
that&rsquo;s where its advantages end. See
<a href=http://georgemauer.net/2017/10/07/csv-injection.html>The Absurdly Underestimated Dangers of CSV Injection</a>
and
<a href=https://haveagreatdata.com/posts/why-you-dont-want-to-use-csv-files/>Why You Don’t Want to Use CSV Files</a>.</p><p>Okay then, let&rsquo;s (begrudgingly) insert the data using CSV:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>quest_db_schema <span style=color:#666>=</span> json<span style=color:#666>.</span>dumps(
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;name&#34;</span>: <span style=color:#4070a0>&#34;ts&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;type&#34;</span>: <span style=color:#4070a0>&#34;TIMESTAMP&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;pattern&#34;</span>: <span style=color:#4070a0>&#34;yyyy-MM-dd HH:mm:ss.U+Z&#34;</span>,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;name&#34;</span>: <span style=color:#4070a0>&#34;size&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;type&#34;</span>: <span style=color:#4070a0>&#34;INT&#34;</span>,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>params <span style=color:#666>=</span> urllib<span style=color:#666>.</span>parse<span style=color:#666>.</span>urlencode(
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#4070a0>&#34;atomicy&#34;</span>: <span style=color:#4070a0>&#34;abort&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#4070a0>&#34;durable&#34;</span>: <span style=color:#4070a0>&#34;true&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#4070a0>&#34;fmt&#34;</span>: <span style=color:#4070a0>&#34;json&#34;</span>,  <span style=color:#60a0b0;font-style:italic># get response as json</span>
</span></span><span style=display:flex><span>        <span style=color:#4070a0>&#34;forceHeader&#34;</span>: <span style=color:#4070a0>&#34;true&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#4070a0>&#34;timestamp&#34;</span>: <span style=color:#4070a0>&#34;ts&#34;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>host <span style=color:#666>=</span> <span style=color:#4070a0>&#34;http://localhost:9000&#34;</span>
</span></span><span style=display:flex><span>ingest_endpoint <span style=color:#666>=</span> <span style=color:#4070a0>f</span><span style=color:#4070a0>&#34;</span><span style=color:#70a0d0>{</span>host<span style=color:#70a0d0>}</span><span style=color:#4070a0>/imp?&#34;</span> <span style=color:#666>+</span> params
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>send_csv_to_questdb</span>(table, table_name):
</span></span><span style=display:flex><span>    options <span style=color:#666>=</span> csv<span style=color:#666>.</span>WriteOptions(include_header<span style=color:#666>=</span><span style=color:#007020;font-weight:700>True</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>with</span> io<span style=color:#666>.</span>BytesIO() <span style=color:#007020;font-weight:700>as</span> buf:
</span></span><span style=display:flex><span>        csv<span style=color:#666>.</span>write_csv(table, buf, options)
</span></span><span style=display:flex><span>        buf<span style=color:#666>.</span>seek(<span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>        res <span style=color:#666>=</span> requests<span style=color:#666>.</span>post(
</span></span><span style=display:flex><span>            ingest_endpoint,
</span></span><span style=display:flex><span>            files<span style=color:#666>=</span>{
</span></span><span style=display:flex><span>                <span style=color:#4070a0>&#34;schema&#34;</span>: quest_db_schema,
</span></span><span style=display:flex><span>                <span style=color:#4070a0>&#34;data&#34;</span>: (table_name, buf),
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> res
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>send_csv_to_questdb(asks_tbl, <span style=color:#4070a0>&#34;asks&#34;</span>)
</span></span><span style=display:flex><span>send_csv_to_questdb(bids_tbl, <span style=color:#4070a0>&#34;bids&#34;</span>)
</span></span></code></pre></div><p>Now for the fun part, querying:</p><pre tabindex=0><code>select bids.ts ts, bids.size as bid, asks.size as ask
from bids
asof join asks;
</code></pre><p>With psql, this is what I get as the output (as expected):</p><pre tabindex=0><code>           ts               │ bid │ ask
════════════════════════════╪═════╪═════
 2019-10-17 00:00:00.000000 │ 100 │   ¤
 2019-10-17 00:00:00.100000 │ 101 │ 100
 2019-10-17 00:00:00.300000 │ 102 │ 101
 2019-10-17 00:00:00.500000 │ 103 │ 102
 2019-10-17 00:00:00.600000 │ 104 │ 102
(5 rows)
</code></pre><p>Notes:</p><ul><li>Given that QuestDB is all about timeseries data, I have to define the
<a href=https://questdb.io/docs/concept/designated-timestamp/>designated timestamp column</a>.
I can do it during query time but defining it when creating the table is more
efficient and makes querying simpler (I don&rsquo;t have to specify the timestamp
columns for the asof join). All the rows for the table table will then have to
be sorted by the designated timestamp column.</li><li>I&rsquo;ve set the <code>atomicity</code> parameter to <code>abort</code> so that in case there are any
errors in the data, QuestDB can forgo ingesting the entire csv rather than
skipping the erroneous rows (which is the default behaviour).</li><li>I probably should set <code>durable</code> parameter to <code>true</code> but it&rsquo;s overkill for this
demo.</li><li>Since I&rsquo;m explicitly providing a header for the CSV, I might as well set
<code>forceHeader</code> to <code>true</code> rather than let QuestDB infer it</li><li>The <code>io.BytesIO()</code> fanfare is all to avoid having to write to disk then read
the CSV back. The data isn&rsquo;t that huge, it can be kept entirely in memory.</li></ul><p>QuestDB does provide other similar kinds of joins:</p><ul><li><code>LT join</code>: Similar to ASOF but the timestamps from the right table that are
matched have to be strictly less than those from the left table: equal
timestamps are not considered.</li><li><code>SPLICE join</code>: If you consider an ASOF join as a left outer join, SPLICE is
the full outer join equivalent.</li></ul><h2 class=heading id=postgresql>PostgreSQL
<a href=#postgresql>#</a></h2><p>Lastly, we&rsquo;ve got PostgreSQL. Unlike previous systems, Postgres doesn&rsquo;t have a
dedicated syntax/API for ASOF joins. But that doesn&rsquo;t mean it can&rsquo;t perform such
queries:</p><p>As usual, let&rsquo;s start by importing the data. Just like QuestDB, we have to do so
via CSV:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>io</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>psycopg2</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>pyarrow.csv</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>csv</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>send_csv_to_pg</span>(cur, to_pg_table: <span style=color:#007020>str</span>, from_arrow_table):
</span></span><span style=display:flex><span>    options <span style=color:#666>=</span> csv<span style=color:#666>.</span>WriteOptions(include_header<span style=color:#666>=</span><span style=color:#007020;font-weight:700>False</span>, delimiter<span style=color:#666>=</span><span style=color:#4070a0>&#34;</span><span style=color:#4070a0;font-weight:700>\t</span><span style=color:#4070a0>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>with</span> io<span style=color:#666>.</span>BytesIO() <span style=color:#007020;font-weight:700>as</span> buf:
</span></span><span style=display:flex><span>        csv<span style=color:#666>.</span>write_csv(from_arrow_table, buf, options)
</span></span><span style=display:flex><span>        buf<span style=color:#666>.</span>seek(<span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>        cur<span style=color:#666>.</span>copy_from(buf, to_pg_table, sep<span style=color:#666>=</span><span style=color:#4070a0>&#34;</span><span style=color:#4070a0;font-weight:700>\t</span><span style=color:#4070a0>&#34;</span>, columns<span style=color:#666>=</span>[<span style=color:#4070a0>&#34;ts&#34;</span>, <span style=color:#4070a0>&#34;size&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>with</span> psycopg2<span style=color:#666>.</span>connect(dsn) <span style=color:#007020;font-weight:700>as</span> conn:
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>with</span> conn<span style=color:#666>.</span>cursor() <span style=color:#007020;font-weight:700>as</span> cur:
</span></span><span style=display:flex><span>        cur<span style=color:#666>.</span>execute(
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4070a0>            create table asks( ts timestamptz not null, size int not null);
</span></span></span><span style=display:flex><span><span style=color:#4070a0>            create table bids( ts timestamptz not null, size int not null);
</span></span></span><span style=display:flex><span><span style=color:#4070a0>            &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        send_csv_to_pg(cur, <span style=color:#4070a0>&#34;asks&#34;</span>, asks_tbl)
</span></span><span style=display:flex><span>        send_csv_to_pg(cur, <span style=color:#4070a0>&#34;bids&#34;</span>, bids_tbl)
</span></span></code></pre></div><p>For querying, we could use a <a href=/p/sql-lateral-joins>left lateral join</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#007020;font-weight:700>select</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>b.ts<span style=color:#bbb> </span>ts,<span style=color:#bbb> </span>b.<span style=color:#007020;font-weight:700>size</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>as</span><span style=color:#bbb> </span>bid,<span style=color:#bbb> </span>a.<span style=color:#007020;font-weight:700>size</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>as</span><span style=color:#bbb> </span>ask<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>from</span><span style=color:#bbb> </span>bids<span style=color:#bbb> </span>b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>left</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>join</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>lateral</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>select</span><span style=color:#bbb> </span>a.<span style=color:#007020;font-weight:700>size</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>from</span><span style=color:#bbb> </span>asks<span style=color:#bbb> </span>a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>where</span><span style=color:#bbb> </span>b.ts<span style=color:#bbb> </span><span style=color:#666>&gt;=</span><span style=color:#bbb> </span>a.ts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>order</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>by</span><span style=color:#bbb> </span>a.ts<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>desc</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>limit</span><span style=color:#bbb> </span><span style=color:#40a070>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>)<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>as</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>on</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>order</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>by</span><span style=color:#bbb> </span>b.ts<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>asc</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Or we could use a correlated subquery (see Timescale&rsquo;s
<a href=https://www.timescale.com/blog/implementing-asof-joins-in-timescale/>Implementing ASOF Joins in PostgreSQL and Timescale</a>
from where I got the idea, and as a bonus, Justin Jaffray&rsquo;s
<a href=https://justinjaffray.com/join-the-ultimate-projection/>JOIN: The Ultimate Projection</a>
on how DBs <em>can</em> decorrelate subqueries):</p><pre tabindex=0><code>select
    b.ts ts,
    b.size as bid,
    (
        select a.size
        from asks a
        where b.ts &gt;= a.ts
        order by a.ts desc
        limit 1
    ) as ask
from bids b
order by b.ts asc
</code></pre><p>Both versions give the same output, though the query plans might be different.
Also, we&rsquo;ll probably have to add some indexing for larger datasets: Pandas,
Polars and QuestDB do rely on the entries being sorted by their timestamps to
speed up processing asof joins.</p><pre tabindex=0><code>            ts            │ bid │ ask
══════════════════════════╪═════╪═════
 2019-10-17 00:00:00+00   │ 100 │   ¤
 2019-10-17 00:00:00.1+00 │ 101 │ 100
 2019-10-17 00:00:00.3+00 │ 102 │ 101
 2019-10-17 00:00:00.5+00 │ 103 │ 102
 2019-10-17 00:00:00.6+00 │ 104 │ 102
(5 rows)
</code></pre><p>We can also use the flexibility of PG&rsquo;s (and DuckDB&rsquo;s) SQL to implement the
threshold and direction parameters that Pandas and Polars had. For example, to
do an asof with &ldquo;nearest&rdquo; direction and within a threshold of 10 milliseconds:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#007020;font-weight:700>select</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>b.ts<span style=color:#bbb> </span>ts,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>b.<span style=color:#007020;font-weight:700>size</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>as</span><span style=color:#bbb> </span>bid,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>a.<span style=color:#007020;font-weight:700>size</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>as</span><span style=color:#bbb> </span>ask<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>from</span><span style=color:#bbb> </span>bids<span style=color:#bbb> </span>b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>left</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>join</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>lateral</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>select</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>a.<span style=color:#007020;font-weight:700>size</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#007020;font-weight:700>case</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#007020;font-weight:700>when</span><span style=color:#bbb> </span>a.ts<span style=color:#bbb> </span><span style=color:#666>&gt;</span><span style=color:#bbb> </span>b.ts<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>then</span><span style=color:#bbb> </span>a.ts<span style=color:#bbb> </span><span style=color:#666>-</span><span style=color:#bbb> </span>b.ts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#007020;font-weight:700>else</span><span style=color:#bbb> </span>b.ts<span style=color:#bbb> </span><span style=color:#666>-</span><span style=color:#bbb> </span>a.ts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#007020;font-weight:700>end</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>as</span><span style=color:#bbb> </span>threshold<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>from</span><span style=color:#bbb> </span>asks<span style=color:#bbb> </span>a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>order</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>by</span><span style=color:#bbb> </span>threshold<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>asc</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>limit</span><span style=color:#bbb> </span><span style=color:#40a070>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>)<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>as</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>on</span><span style=color:#bbb> </span>threshold<span style=color:#bbb> </span><span style=color:#666>&lt;=</span><span style=color:#bbb> </span><span style=color:#4070a0>&#39;10 milliseconds&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>order</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>by</span><span style=color:#bbb> </span>b.ts<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>asc</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 class=heading id=notable-mentions>Notable mentions
<a href=#notable-mentions>#</a></h2><p>There are other systems that implement ASOF joins (e.g.
<a href=https://clickhouse.com/docs/en/sql-reference/statements/select/join#asof-join-usage>Clickhouse</a>
and <a href=https://blog.quasar.ai/timeseries-what-are-asof-joins>QuasarDB</a>) but even
if they don&rsquo;t, if they&rsquo;ve got SQL, you can always use subqueries and/or lateral
joins to do the same. I&rsquo;m particularly interested in Clickhouse, I just haven&rsquo;t
had a good reason to use it yet beyond curiosity; every dataset I&rsquo;ve worked with
so far is DuckDB/SQLite sized. In future, I&rsquo;d also love to go over the query
plans and optimizations made by DuckDB, Postgres and Timescale when evaluating
asof-style joins for larger datasets.</p><h2 class=heading id=referencesfurther-reading>References/Further Reading
<a href=#referencesfurther-reading>#</a></h2><ul><li><a href=https://duckdb.org/docs/guides/sql_features/asof_join.html>DuckDB ASOF Join</a></li><li><a href=https://questdb.io/docs/reference/sql/join/#asof-join>QuestDB ASOF JOIN</a></li><li><a href=https://pandas.pydata.org/docs/reference/api/pandas.merge_asof.html>Pandas merge_asof API documentation</a></li><li><a href=https://angwalt12.medium.com/the-hidden-rules-of-pandas-merge-asof-e67293a5318e>The hidden rules of pandas.merge_asof() - Angwalt</a></li><li><a href=https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.join_asof.html>polars.DataFrame.join_asof</a></li><li><a href=https://florianwilhelm.info/2021/05/polars_pandas_comparison_notebook/>A Practical Comparison of Polars and Pandas - Florian Wilhelm</a></li><li><a href=https://www.timescale.com/blog/implementing-asof-joins-in-timescale/>Implementing ASOF Joins in PostgreSQL and Timescale - James Blackwood-Sewell,
Kirk Laurence Roybal</a></li><li><a href=https://www.timescale.com/blog/time-series-data/>All Data is Time-Series Data (With Examples) - Ajay Kulkarni, Ryan Booz,
Attilla Toth</a></li><li><a href=https://www.postgresql.org/message-id/CALzhyqwuVz0FJZ-oCYQ9d%2ByrPrbF5a9HDyAjxuSUdgq8n7nshQ%40mail.gmail.com>[RFC] ASOF Join - Alexander Kuzmenkov - pgsql-hackers mailing list</a></li></ul><script src=https://giscus.app/client.js data-repo=bnmoch3/blog data-repo-id=R_kgDOIU86DQ data-category data-category-id=DIC_kwDOIU86Dc4Clvgl data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=gruvbox_light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/p/postgres-roles-users-groups-privileges/>PostgreSQL: Managing Roles, Attributes and Privileges</a></div></div></div><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text><a href=/p/pg-parquet-archive-timeseries/>Archiving Time-Series Data from PostgreSQL into Parquet</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>&mldr;</p></footer><script async src=https://scripts.simpleanalyticscdn.com/latest.js></script></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>