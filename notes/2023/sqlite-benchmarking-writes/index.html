<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://bnmoch3.org/favicon.ico?><link rel=icon type=image/png sizes=16x16 href=https://bnmoch3.org/favicon-16x16.png?><link rel=icon type=image/png sizes=32x32 href=https://bnmoch3.org/favicon-32x32.png?><link rel=icon type=image/png sizes=192x192 href=https://bnmoch3.org/android-chrome-192x192.png?><link rel=apple-touch-icon sizes=180x180 href=https://bnmoch3.org/apple-touch-icon.png?><meta name=description content><title>Benchmarking SQLite inserts | bnmoch3
</title><link rel=canonical href=https://bnmoch3.org/notes/2023/sqlite-benchmarking-writes/><meta property="og:url" content="https://bnmoch3.org/notes/2023/sqlite-benchmarking-writes/"><meta property="og:site_name" content="bnmoch3"><meta property="og:title" content="Benchmarking SQLite inserts"><meta property="og:description" content="Going from 750 writes per second to 25,0000 with a bit of configuring"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2023-04-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-16T00:00:00+00:00"><meta property="article:tag" content="Misc"><link rel=stylesheet href=/assets/combined.min.01980ad4202828eb32272e7b1654f79f3c0022c15b1c932668dff73dffaf7e88.css media=all></head><body class=light><div class=content><header><div class=header><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/about>/about</a></p><p class=small><a href=/posts>/posts</a></p><p class=small><a href=/notes>/notes</a></p><p class=small><a href=/tags>/tags</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/notes/>Notes</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/notes/2023/sqlite-benchmarking-writes/>Benchmarking SQLite inserts</a></div><div><div class=single-intro-container><h1 class=single-title>Benchmarking SQLite inserts</h1><p class=single-readtime><time datetime=2023-04-16T00:00:00+00:00>April 16, 2023</time>
&nbsp; Â· &nbsp;
4 min read</p></div><div class=single-content><h2 class=heading id=overview>Overview
<a href=#overview>#</a></h2><p>It&rsquo;s always worth replicating a benchmark, you know, for science. For today,
I&rsquo;ll be replicating
<a href=https://kerkour.com/high-performance-rust-with-sqlite>Kerkour&rsquo;s SQLite inserts benchmark</a>
partly for the sake of it, partly to familiarize myself with using SQLite from
rust. Quick warning, expect a lot of hand-wavey-ness.</p><h2 class=heading id=benchmarking>Benchmarking
<a href=#benchmarking>#</a></h2><p>We&rsquo;ll use the following helper to set up the table:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#007020;font-weight:700>fn</span> <span style=color:#06287e>init_db</span>(conn: <span style=color:#007020>&amp;</span><span style=color:#0e84b5;font-weight:700>rusqlite</span>::Connection)<span style=color:#bbb> </span>-&gt; <span style=color:#0e84b5;font-weight:700>rusqlite</span>::<span style=color:#007020>Result</span><span style=color:#666>&lt;</span>()<span style=color:#666>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>conn.execute(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#4070a0>&#34;CREATE TABLE users(
</span></span></span><span style=display:flex><span><span style=color:#4070a0>            id BLOB PRIMARY KEY NOT NULL,
</span></span></span><span style=display:flex><span><span style=color:#4070a0>            created_at TEXT NOT NULL,
</span></span></span><span style=display:flex><span><span style=color:#4070a0>            username TEXT NOT NULL
</span></span></span><span style=display:flex><span><span style=color:#4070a0>        )&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>(),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>)<span style=color:#666>?</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>conn.execute(<span style=color:#4070a0>&#34;CREATE UNIQUE INDEX idx_users_on_id ON users(id)&#34;</span>,<span style=color:#bbb> </span>())<span style=color:#666>?</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020>Ok</span>(())<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>And here&rsquo;s how the data is generated and inserted:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#007020>#[derive(Debug)]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>struct</span> <span style=color:#0e84b5;font-weight:700>User</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>id: <span style=color:#0e84b5;font-weight:700>uuid</span>::Uuid,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>created_at: <span style=color:#0e84b5;font-weight:700>chrono</span>::DateTime<span style=color:#666>&lt;</span>chrono::Utc<span style=color:#666>&gt;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>username: <span style=color:#007020>String</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>let</span><span style=color:#bbb> </span>u<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>User<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>id: <span style=color:#0e84b5;font-weight:700>uuid</span>::Uuid::new_v4(),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>created_at: <span style=color:#0e84b5;font-weight:700>chrono</span>::Utc::now(),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>username: <span style=color:#007020>String</span>::from(<span style=color:#4070a0>&#34;Someone&#34;</span>),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>};<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>conn.execute(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#4070a0>&#34;INSERT INTO users(id, created_at, username) VALUES (?, ?, ?)&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>(<span style=color:#666>&amp;</span>u.id.to_string(),<span style=color:#bbb> </span><span style=color:#666>&amp;</span>u.created_at.to_rfc3339(),<span style=color:#bbb> </span><span style=color:#666>&amp;</span>u.username),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>)<span style=color:#666>?</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>My code differs quite a bit from Kerkour, particularly in the following ways:</p><ul><li>usage of the <a href=https://github.com/rusqlite/rusqlite>rusqlite</a> instead of
<a href=https://github.com/launchbadge/sqlx>sqlx</a></li><li>usage of threads directly instead of tokio (which sqlx uses);</li></ul><p>Relying solely on the SQLite and the driver&rsquo;s defaults, I get a paltry 756
inserts per second. This is with one thread. Building and running with release
mode, I get 764 inserts per second, so I probably need to tune some
sqlite-specific knobs here and there.</p><h2 class=heading id=concurrent-multi-threaded-inserts>Concurrent (multi-threaded) Inserts
<a href=#concurrent-multi-threaded-inserts>#</a></h2><p>With 4 threads and 10,000 inserts per thread, I get:
<code>DatabaseBusy...database is locked</code> inserts per second (aka some error). My
first guess is that it&rsquo;s probably the <code>threading mode</code> configuration. I know
that SQLite does not allow for concurrent write transactions but it should allow
for concurrent connections?</p><p>From SQLite&rsquo;s <a href=https://www.sqlite.org/threadsafe.html>documentation</a>, SQLite
supports the following threading modes:</p><ol><li>Single-thread: all mutexes are disabled, unsafe to use in more than a
single-thread at once</li><li>Multi-thread: can be used safely across multiple threads as long as no
database connection is used simultaneously in two or more threads.</li><li>Serialized: safe to use by multiple threads with no restriction</li></ol><p>The threading mode can be configured at compile-time, application start-time or
when creating a connection. SQLite&rsquo;s default mode is <code>serialized</code> which is what
I suspect is causing the <code>DatabaseBusy</code> error. However, as per rusqlite&rsquo;s docs,
rusqlite overrides this setting during connection into multi-threaded mode.
Assumption invalidated, so the error is probably at some other level.</p><p>My second hunch is that once a connection is used for Insert/Update/Drop, it
acquires a write-lock that it holds throughout the entirety of the connection
rather than per each statement execution/transaction. I&rsquo;ll definitely have to
dig into SQLite docs/internals at some point to confirm this but for the
time-being, I&rsquo;ll go by rustqlite&rsquo;s docs which don&rsquo;t (seem to) indicate that
connections are created lazily.</p><p>Therefore, a quick solution might be to create a connection for each insert:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#007020;font-weight:700>for</span><span style=color:#bbb> </span>_<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:#40a070>0</span><span style=color:#666>..</span>num_inserts_per_thread<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>let</span><span style=color:#bbb> </span>u<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>User::gen();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#007020;font-weight:700>let</span><span style=color:#bbb> </span>conn<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>rusqlite::Connection::open(<span style=color:#4070a0>&#34;db.sqlite&#34;</span>).unwrap();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>conn.execute(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#4070a0>&#34;INSERT INTO users(id, created_at, username) VALUES (?, ?, ?)&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>(<span style=color:#666>&amp;</span>u.id.to_string(),<span style=color:#bbb> </span><span style=color:#666>&amp;</span>u.created_at.to_rfc3339(),<span style=color:#bbb> </span><span style=color:#666>&amp;</span>u.username),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>.unwrap();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>This still doesn&rsquo;t prevent the <code>DatabaseBusy</code> error so I&rsquo;m guessing I&rsquo;ll have to
treat it as a retriable error and ignore it:</p><pre tabindex=0><code>let mut inserted = 0;
while inserted &lt; num_inserts_per_thread {
    let u = User::gen();
    let conn = get_conn().unwrap();
    let res = conn.execute(
        &#34;INSERT INTO users(id, created_at, username) VALUES (?, ?, ?)&#34;,
        (&amp;u.id.to_string(), &amp;u.created_at.to_rfc3339(), &amp;u.username),
    );
    if let Err(e) = res {
        if e.sqlite_error_code() != Some(rusqlite::ErrorCode::DatabaseBusy) {
            panic!(&#34;{}&#34;, e);
        }
    } else {
        inserted += 1;
    }
}
</code></pre><p>One advantage of creating a connection for each insert is that threads can do
inserts in parallel rather than serially.</p><h2 class=heading id=using-connection-pooling>Using connection pooling.
<a href=#using-connection-pooling>#</a></h2><p>A slightly different solution is to use connection pooling. I am familiar with
connection pooling courtesy of Postgres-isms but it &lsquo;feels&rsquo; awkward to use
pooling when the database is right there embedded in the process rather than
over across a network. I&rsquo;ll get back to this later on.</p><h2 class=heading id=transactions>Transactions
<a href=#transactions>#</a></h2><p>Alternatively, I could use explicit transactions for each insert. My guess is
that on commit/rollback, the connection cedes the write lock and on the next
insert within a given connection has to re-acquire the lock. I&rsquo;ll try this out
too to see if it works, plus also read the docs to see if this is the case.</p><h2 class=heading id=optimizing-single-threaded-inserts>Optimizing single-threaded inserts.
<a href=#optimizing-single-threaded-inserts>#</a></h2><p>Back to single-thread world; the roughly 750 inserts per second is still quite
low. Let&rsquo;s try some optimizations</p><ol><li>Set journal mode to WAL. This immediately increases insert speeds from ~750
to ~2500.</li><li>Set synchronous to <code>NORMAL</code>. This gets us to ~25,000 inserts per second.</li></ol><p>Other optimizations I&rsquo;ve tried event though they don&rsquo;t seem to have a huge
effect:</p><ul><li>Set <code>temp_store</code> to<code>MEMORY</code></li><li>Set <code>locking_mode</code> to<code>EXCLUSIVE</code></li><li>Set <code>cache_size</code> to ~1GB</li><li>Use prepared statements</li></ul><script src=https://giscus.app/client.js data-repo=bnmoch3/blog data-repo-id=R_kgDOIU86DQ data-category data-category-id=DIC_kwDOIU86Dc4Clvgl data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=gruvbox_light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text>â</div><div class=single-pagination-text><a href=/notes/2023/goroutine-panics/>Handling panics from goroutines you've spawned</a></div></div></div><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text><a href=/notes/2023/getting-started-tla/>Getting started with TLA+</a></div><div class=single-pagination-text>â</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>&mldr;</p></footer><script async src=https://scripts.simpleanalyticscdn.com/latest.js></script></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>