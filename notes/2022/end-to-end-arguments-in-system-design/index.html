<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://www.bnmoch3.org//favicon.ico?><link rel=icon type=image/png sizes=16x16 href=https://www.bnmoch3.org//favicon-16x16.png?><link rel=icon type=image/png sizes=32x32 href=https://www.bnmoch3.org//favicon-32x32.png?><link rel=icon type=image/png sizes=192x192 href=https://www.bnmoch3.org//android-chrome-192x192.png?><link rel=apple-touch-icon sizes=180x180 href=https://www.bnmoch3.org//apple-touch-icon.png?><meta name=description content><title>End-to-End Arguments in System Design | bnmoch3
</title><link rel=canonical href=https://www.bnmoch3.org/notes/2022/end-to-end-arguments-in-system-design/><meta property="og:url" content="https://www.bnmoch3.org/notes/2022/end-to-end-arguments-in-system-design/"><meta property="og:site_name" content="bnmoch3"><meta property="og:title" content="End-to-End Arguments in System Design"><meta property="og:description" content="Paper Review"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2022-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-30T00:00:00+00:00"><meta property="article:tag" content="Distributed Systems"><meta property="article:tag" content="Paper Review"><link rel=stylesheet href=/assets/combined.min.01980ad4202828eb32272e7b1654f79f3c0022c15b1c932668dff73dffaf7e88.css media=all></head><body class=light><div class=content><header><div class=header><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/about>/about</a></p><p class=small><a href=/posts>/posts</a></p><p class=small><a href=/notes>/notes</a></p><p class=small><a href=/tags>/tags</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/notes/>Notes</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/notes/2022/end-to-end-arguments-in-system-design/>End-to-End Arguments in System Design</a></div><div><div class=single-intro-container><h1 class=single-title>End-to-End Arguments in System Design</h1><p class=single-readtime><time datetime=2022-10-30T00:00:00+00:00>October 30, 2022</time>
&nbsp; · &nbsp;
2 min read</p></div><div class=single-content><p>The classic paper
<a href=https://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf>&lsquo;End-to-End arguments in System Design&rsquo;</a>
presents the end-to-end argument, a design principle that states functionality
should be moved &ldquo;closer to the application that uses the function&rdquo; i.e. at the
endpoints.</p><blockquote><p>The function in question can completely and correctly be implemented only with
the knowledge and help of the application standing at the end points of the
communication system. Therefore, providing that questioned function as a
feature of the communication system itself is not possible.</p></blockquote><p>This is because:</p><blockquote><p>functions placed at low levels of a system may be redundant or of little value
compared with the cost of providing them at that low level.</p></blockquote><p>In a layered system, there are various levels where functionality can be
implemented:</p><ul><li>at the communication subsystem</li><li>by the client (endpoints)</li><li>the client jointly coordinating with the lower levels</li><li>redundantly at each level</li></ul><p>Some of these functionalities include:</p><ul><li>message sequencing (FIFO)</li><li>message deduplication</li><li>guaranteed message delivery</li><li>detecting node failures</li><li>detecting message corruption (checksumming)</li><li>retries</li><li>encryption</li><li>effectively once execution of an operation (e.g. via idempotency and/or
deduplication) [4]</li><li>e.t.c</li></ul><p>The authors are not entirely against implementing functionalities at lower
levels, just that we shouldn&rsquo;t expect (and burden) these levels with capturing
and reliably guaranteeing all the different kinds of requirements that our
applications have. Implementing some functionality in the lower layers can be
useful for optimizing performance (in some carefully evaluated cases). However,
we should proceed with caution since applications that don&rsquo;t need that
functionality still have to pay for it. Furthermore, certain functionalities
require information that can only be surfaced at the endpoints.</p><h2 class=heading id=reference>Reference
<a href=#reference>#</a></h2><ol><li>End-To-End Arguments In System Design - Saltzer, Reed, Clark:
<a href=https://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf>pdf</a></li><li>Paper Summary: End-to_end Arguments in System Design - Dominik Tornow:
<a href=https://temporal.io/blog/paper-summary-end-to-end-arguments-in-system-design>post</a></li><li>End-to-End arguments in System Design - The Morning Paper - Adrian Coyler:
<a href=https://blog.acolyer.org/2014/11/14/end-to-end-arguments-in-system-design/>post</a></li><li>The End-to-End Arguments for Databases - Designing Data-Intensive
Applications - Martin Kleppmann - Book</li></ol></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/notes/2023/getting-started-tla/>Getting started with TLA+</a></div></div></div><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text><a href=/notes/2022/distributed-reference-counting/>Distributed Reference Counting</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>&mldr;</p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>