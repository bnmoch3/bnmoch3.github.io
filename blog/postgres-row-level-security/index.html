<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://bnm3k.github.io//favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bnm3k.github.io//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bnm3k.github.io//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://bnm3k.github.io//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://bnm3k.github.io//apple-touch-icon.png><meta name=description content><title>Fine-grained Authorization with Row Level Security in PostgreSQL | bnm 3000
</title><link rel=canonical href=https://bnm3k.github.io/blog/postgres-row-level-security/><meta property="og:url" content="https://bnm3k.github.io/blog/postgres-row-level-security/"><meta property="og:site_name" content="bnm 3000"><meta property="og:title" content="Fine-grained Authorization with Row Level Security in PostgreSQL"><meta property="og:description" content="Tutorial on RLS"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-24T00:00:00+00:00"><meta property="article:tag" content="PostgreSQL"><link rel=stylesheet href=/assets/combined.min.186794b3399a702d3092949042cdc215dea303c17e71e7c0254768448de11db8.css media=all></head><body class=light><div class=content><header><div class=header><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/posts>/posts</a></p><p class=small><a href=/notes>/notes</a></p><p class=small><a href=/tags>/tags</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/posts/>Posts</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/blog/postgres-row-level-security/>Fine-grained Authorization with Row Level Security in PostgreSQL</a></div><div class=autonumber><div class=single-intro-container><h1 class=single-title>Fine-grained Authorization with Row Level Security in PostgreSQL</h1><p class=single-readtime><time datetime=2024-12-24T00:00:00+00:00>December 24, 2024</time>
&nbsp; · &nbsp;
21 min read</p></div><div class=single-tags><span><a href=https://bnm3k.github.io/tags/postgresql/>#PostgreSQL</a></span></div><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#demo-database>Demo Database</a></li><li><a href=#authorization-strategy>Authorization Strategy</a></li><li><a href=#roles--privileges>Roles & Privileges</a></li><li><a href=#rls-on-the-members-table>RLS on the Members Table</a><ul><li><a href=#permissive--restrictive-policies>Permissive & Restrictive Policies</a></li></ul></li><li><a href=#rls-on-the-bookings-table>RLS on the Bookings Table</a><ul><li><a href=#with-check-clause-for-inserts--updates>With Check Clause for Inserts & Updates</a></li></ul></li><li><a href=#rls-with-sessionlocal-variables>RLS with Session/Local Variables</a><ul><li><a href=#refactoring-internal-ids--external-ids>Refactoring, Internal IDs & External IDs</a></li><li><a href=#rls-infinite-recursion--security-definer-functions>RLS, Infinite Recursion & Security Definer Functions</a></li><li><a href=#bringing-it-all-together-rls-external-ids-and-local-variables>Bringing It All Together: RLS, External IDs and Local Variables</a></li></ul></li><li><a href=#rls--jwt>RLS & JWT</a></li><li><a href=#view-permissions-security-invoker-views-and-rls>View Permissions, Security Invoker Views and RLS</a></li><li><a href=#optimizing-row-level-security>Optimizing Row Level Security</a></li><li><a href=#references>References</a></li></ul></nav></aside><div class=single-content><h2 class=heading id=intro>Intro
<a href=#intro>#</a></h2><p>Row-Level Security (RLS) is a PostgreSQL mechanism that lets us implement
authorization policies and pre-conditions over which rows in a table a user can
insert/read/modify/delete. It is meant to complement other authorization and
security measures such as the roles & privileges system rather than replace them
entirely.</p><p>In this post, I&rsquo;ll be going over how RLS works, various caveats and how you can
go about implementing it.</p><h2 class=heading id=demo-database>Demo Database
<a href=#demo-database>#</a></h2><p>For the sake of demonstration I&rsquo;ll be using the database from the
<a href=https://pgexercises.com/gettingstarted.html>pgexercises</a> SQL tutorial site.
It&rsquo;s &ldquo;for a newly created country club, with a set of members, facilities such
as tennis courts, and booking history for those facilities&rdquo;. The database
consists of 3 tables:</p><p>The <code>members</code> table:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>table</span> members (
</span></span><span style=display:flex><span>    memid integer <span style=font-weight:700>primary</span> <span style=font-weight:700>key</span>,
</span></span><span style=display:flex><span>    surname varchar(200) <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    firstname varchar(200) <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    address varchar(300) <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    zipcode integer <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    telephone varchar(20) <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    recommendedby integer <span style=font-weight:700>references</span> members(memid) <span style=font-weight:700>on</span> <span style=font-weight:700>delete</span> <span style=font-weight:700>set</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    joindate <span style=font-weight:700>timestamp</span> <span style=font-weight:700>without</span> time <span style=font-weight:700>zone</span> <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>The <code>facilities</code> table which holds all the amenities the club has to offer:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>table</span> facilities (
</span></span><span style=display:flex><span>    facid integer <span style=font-weight:700>primary</span> <span style=font-weight:700>key</span>,
</span></span><span style=display:flex><span>    name varchar(100) <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    membercost numeric <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    guestcost numeric <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    initialoutlay numeric <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    monthlymaintenance numeric <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>And the <code>bookings</code> table:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>table</span> bookings (
</span></span><span style=display:flex><span>    bookid integer <span style=font-weight:700>primary</span> <span style=font-weight:700>key</span>,
</span></span><span style=display:flex><span>    facid integer <span style=font-weight:700>not</span> <span style=font-weight:700>null</span> <span style=font-weight:700>references</span> facilities(facid),
</span></span><span style=display:flex><span>    memid integer <span style=font-weight:700>not</span> <span style=font-weight:700>null</span> <span style=font-weight:700>references</span> members(memid),
</span></span><span style=display:flex><span>    starttime <span style=font-weight:700>timestamp</span> <span style=font-weight:700>without</span> time <span style=font-weight:700>zone</span> <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>,
</span></span><span style=display:flex><span>    slots integer <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h2 class=heading id=authorization-strategy>Authorization Strategy
<a href=#authorization-strategy>#</a></h2><p>There will be two kinds of people that will access the database: the admin and
club members. The admin will have no restrictions. As for the members, we want
to limit what each can do. Let&rsquo;s go over the restrictions table by table</p><p>For the members table:</p><ul><li>A member can only read their own membership details OR membership details for
the members they directly recommended to join the club</li><li>A member can only modify their own membership details, they are not allowed to
touch any other members&rsquo; details</li><li>The only fields a member can modify are the <code>address</code>, <code>zipcode</code> and
<code>telephone</code> fields - the rest have to handled by admin</li><li>A member cannot insert new members nor delete any current member including
themselves, this will be handled by the admin</li></ul><p>For the facilities table:</p><ul><li>A member can read all the facilities available</li><li>A member cannot insert/modify/delete any facility</li></ul><p>For the bookings table:</p><ul><li>A member can only read their own bookings. They should not be able to read
bookings made by other members.</li><li>A member can insert/modify/delete a new booking as long as that booking has
their membership ID and it&rsquo;s set in the future.</li><li>When modifying a booking, the only fields a member is allowed to change are
the <code>facid</code> (facility), <code>starttime</code> and <code>slots</code>.</li></ul><p>RLS by itself cannot be used to implement all these restrictions, we will start
with Postgres&rsquo; roles/privileges system then bring in RLS:</p><h2 class=heading id=roles--privileges>Roles & Privileges
<a href=#roles--privileges>#</a></h2><p>There is an admin superuser already setup. The admin role created and owns the
database. Each member will have separate user roles that they can use to login
in and access the database. The admin will create each member&rsquo;s roles as part of
onboarding.</p><p>Rather than grant privileges one-by-one to each member, we&rsquo;ll create a <em>group</em>
role, <code>member_access</code>, which will <em>hold</em> all the privileges - permissions given
to members. From there, whenever a member role is added to <code>member_access</code>, it
will inherit all the requisite privileges.</p><p>Here is <code>member_access</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>role</span> member_access; <span style=font-style:italic>-- no login
</span></span></span></code></pre></div><p>We&rsquo;ll need to give <code>member_access</code> permission to access all the objects held
within the database&rsquo;s main schema, <code>cd</code>. Usually, this is not a permission we
think much of when creating roles since if we&rsquo;re using the <code>public</code> schema
(which is the default schema) then it is already configured to grant usage and
modification permission to all roles. However, given that we&rsquo;re using a
non-default schema, we&rsquo;ll have to grant <code>usage</code> to the <code>member_access</code> role,
otherwise members will not be able to view any of the tables:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>grant</span> <span style=font-weight:700>usage</span> <span style=font-weight:700>on</span> <span style=font-weight:700>schema</span> cd <span style=font-weight:700>to</span> member_access;
</span></span></code></pre></div><p>A member can view all the facilities available, but they cannot modify any:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>grant</span> <span style=font-weight:700>select</span> <span style=font-weight:700>on</span> cd.facilities <span style=font-weight:700>to</span> member_access;
</span></span></code></pre></div><p>A member can view or update membership details (in the <code>cd.members</code> table) but
can&rsquo;t add new members or make any deletions. The updates a member can make are
limited to the <code>address</code>, <code>zipcode</code> and <code>telephone</code> columns.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>grant</span> <span style=font-weight:700>select</span> <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>to</span> member_access;
</span></span><span style=display:flex><span><span style=font-weight:700>grant</span> <span style=font-weight:700>update</span> (address,zipcode,telephone) <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>to</span> member_access;
</span></span></code></pre></div><p>Above, we can see where the roles & privileges system works best and where RLS
works best and how both can complement each other: while we can use the roles &
privileges system to limit which columns can be modified, we can&rsquo;t use it to
prevent one member from modifying another member&rsquo;s details - in order to
implement the latter, we&rsquo;ll have to use row-level security. Let&rsquo;s proceed to the
last table, <code>bookings</code>:</p><p>A member can select, update, delete or insert a booking (again, we&rsquo;ll tighten
what exactly a member can do with RLS):</p><pre tabindex=0><code>grant select, insert, update(facid,starttime, slots), delete
  on cd.bookings to member_access;
</code></pre><p>Now let&rsquo;s create an actual member and add them to the <code>member_access</code> group.
Note, each member name will have the format <code>member_</code> + member ID.</p><pre tabindex=0><code>create role member_2 with login password &#39;super_secret_password&#39;;
grant member_access to member_2;
alter role member_2 set search_path to cd;
</code></pre><h2 class=heading id=rls-on-the-members-table>RLS on the Members Table
<a href=#rls-on-the-members-table>#</a></h2><p>We&rsquo;ll start with the <code>members</code> table then the <code>bookings</code> table. For the
<code>facilities</code> table, we&rsquo;ve already achieved all the authorization goals by
granting members only the ability to select from the table and nothing else - so
we won&rsquo;t be enabling RLS on that table.</p><p>On the <code>members</code> table, RLS is enabled as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>table</span> members enable <span style=font-weight:700>row</span> <span style=font-weight:700>level</span> <span style=font-weight:700>security</span>;
</span></span></code></pre></div><p>In a separate session, we can log in as <code>member_2</code>. The first observation is
that <code>member_2</code> can&rsquo;t <em>see</em> any row from <code>members</code> after RLS is enabled:</p><pre tabindex=0><code>member_2@club=&gt; select * from members;
 memid │ surname │ firstname │ address │ zipcode │ telephone │ recommendedby │ joindate
═══════╪═════════╪═══════════╪═════════╪═════════╪═══════════╪═══════════════╪══════════
(0 rows)
</code></pre><p>After enabling RLS on a table, we have to specify a policy. The policy is
evaluated for each row we&rsquo;re selecting (or modifying) and if the policy returns
true, upstream operators can access the row, otherwise if false is returned, the
row is filtered out. Without any policy present, Postgres opts for a
<code>default-deny</code> policy which means that false is returned for every row.</p><p>Let&rsquo;s add a policy:</p><p>First, a member should be able to read their own membership details:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_self_read_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> cd.members
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>);
</span></span></code></pre></div><p><code>current_user</code> is a Postgres function that returns the currently logged-in DB
user
(<a href=https://neon.tech/postgresql/postgresql-administration/postgresql-current_user>PostgreSQL CURRENT_USER</a>).</p><p>If we run it as <code>member_2</code> we get:</p><pre tabindex=0><code>member_2@club=&gt; select current_user;
 current_user
══════════════
 member_2
</code></pre><p>With the above policy in place, member 2 can now read their own details</p><pre tabindex=0><code>member_2@club=&gt; select memid, firstname, surname from members;
 memid │ firstname │ surname
═══════╪═══════════╪═════════
     2 │ Tracy     │ Smith
(1 row)
</code></pre><p>Additionally, we want members to be able to read the details of other members
whom they recommended to join the club. Luckily, Postgres let&rsquo;s us apply more
than one policy to a table:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_recs_read_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> cd.members
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| recommendedby = <span style=font-weight:700>current_user</span>);
</span></span></code></pre></div><p>Now member 2 can see also read details of all the members she recommended:</p><pre tabindex=0><code>member_2@club=&gt; select memid, firstname, surname, recommendedby from members;
 memid │ firstname │      surname      │ recommendedby
═══════╪═══════════╪═══════════════════╪═══════════════
    29 │ Henry     │ Worthington-Smyth │             2
    30 │ Millicent │ Purview           │             2
    36 │ Erica     │ Crumpet           │             2
     2 │ Tracy     │ Smith             │             ¤
(4 rows)
</code></pre><h3 class=heading id=permissive--restrictive-policies>Permissive & Restrictive Policies
<a href=#permissive--restrictive-policies>#</a></h3><p>Postgres has two ways of combining policies whenever they apply to the same
query:</p><ul><li>as <code>permissive</code></li><li>as <code>restrictive</code></li></ul><p>With permissive, policies are combined using logical <code>or</code>, that is if a row is
not cleared using policy 1, we check policy 2 and so on until it&rsquo;s cleared by at
least one policy. Otherwise it is filtered out. On the other hand, with
restrictive, policies are combined using logical <code>and</code>, that is a row must be
cleared by all the restrictive policies present on the table - if it fails at
least one restrictive policy, then it&rsquo;s filtered out. Policies default to
permissive unless specified otherwise, which is what we&rsquo;ve got with the two
policies above</p><p>Alternatively, we could have rewritten the two policies as a single policy:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_read_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>select</span> <span style=font-weight:700>using</span>
</span></span><span style=display:flex><span>    ((<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>) <span style=font-weight:700>or</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| recommendedby = <span style=font-weight:700>current_user</span>))
</span></span></code></pre></div><p>Lest we forget, let&rsquo;s also add the policy on updates: a member should only be
allowed to update their own details and no one elses:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_update_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>update</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>)
</span></span></code></pre></div><p>This now works:</p><pre tabindex=0><code>member_2@club=&gt; update members set telephone=&#39;445-445-4445&#39; where memid=2;
UPDATE 1
</code></pre><p>We can even leave out the <code>where</code> clause since RLS will ensure the update only
applies to the member&rsquo;s own row:</p><pre tabindex=0><code>member_2@club=&gt; update members set telephone=&#39;333-333-3332&#39;;
UPDATE 1
member_2@club=&gt; select memid, telephone from members where memid = 2;
 memid │  telephone
═══════╪══════════════
     2 │ 333-333-3332
(1 row)
</code></pre><h2 class=heading id=rls-on-the-bookings-table>RLS on the Bookings Table
<a href=#rls-on-the-bookings-table>#</a></h2><p>Now, for the <code>bookings</code> table:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>table</span> cd.bookings enable <span style=font-weight:700>row</span> <span style=font-weight:700>level</span> <span style=font-weight:700>security</span>
</span></span></code></pre></div><p>The first policy we&rsquo;ll create on <code>bookings</code> is that all the rows a member
selects/updates/deletes/inserts have to have that member&rsquo;s ID:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_gen_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> permissive <span style=font-weight:700>for</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>)
</span></span></code></pre></div><p>Since it&rsquo;s a permissive policy, it lets us add restrictive policies down the
line (those require us to have at least one permissive policy setup on the
table). In fact, let&rsquo;s go right ahead and add one. We don&rsquo;t want members to
&lsquo;change&rsquo; the past, only the future. That is, a member can only
modify/delete/insert a booking if the start time of that booking is >= <code>now()</code>.
Usually I&rsquo;d implement this using both constraints and triggers but let&rsquo;s see how
to do it with RLS:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_del_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> restrictive <span style=font-weight:700>for</span> <span style=font-weight:700>delete</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (starttime &gt; now());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_upd_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> restrictive <span style=font-weight:700>for</span> <span style=font-weight:700>update</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> <span style=font-weight:700>check</span> (starttime &gt; now());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_ins_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> restrictive <span style=font-weight:700>for</span> <span style=font-weight:700>insert</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> <span style=font-weight:700>check</span> (starttime &gt; now());
</span></span></code></pre></div><h3 class=heading id=with-check-clause-for-inserts--updates>With Check Clause for Inserts & Updates
<a href=#with-check-clause-for-inserts--updates>#</a></h3><p>The policies above ensure that a member cannot &lsquo;change&rsquo; the past. It&rsquo;s worth
noting the usage of <code>with check</code> in <code>bookings_ins_policy</code> and
<code>bookings_upd_policy</code>.</p><p>From the docs, the check expression:</p><blockquote><p>will be used in INSERT and UPDATE queries against the table if row-level
security is enabled. Only rows for which the expression evaluates to true will
be allowed. An error will be thrown if the expression evaluates to false or
null for any of the records inserted or any of the records that result from
the update. Note that the check_expression is evaluated against the proposed
new contents of the row, not the original contents.</p></blockquote><p>On the other hand, with using:</p><blockquote><p>This expression will be added to queries that refer to the table if row-level
security is enabled. Rows for which the expression returns true will be
visible. Any rows for which the expression returns false or null will not be
visible to the user (in a SELECT), and will not be available for modification
(in an UPDATE or DELETE). Such rows are silently suppressed; no error is
reported.</p></blockquote><p>Also, all the new policies are restrictive. This means for example when we
insert a row as <code>member_2</code>, the expression
<code>('member_'|| memid = current_user) AND (starttime > now())</code> will be ran against
the new row and if the expression returns true, that row will be allowed,
otherwise we&rsquo;ll get an error. If <code>bookings_ins_policy</code> was permissive, the
expression would instead be:
<code>('member_'|| memid = current_user) OR (starttime > now())</code>. This means a member
could create a booking in the &ldquo;past&rdquo; OR they could even insert a booking on
behalf of another member since only one of the disjuncts has to evaluate to True
for the entire expression to be True. By the way, whenever we don&rsquo;t specify a
<code>with check</code> expression, the <code>using</code> expression is used in place of the
<code>check expression</code>. So the <code>bookings_gen_policy</code> is effectively as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_gen_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> permissive <span style=font-weight:700>for</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>)
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> <span style=font-weight:700>check</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>)
</span></span></code></pre></div><p>Additionally, instead of having 4 different policies on <code>bookings</code>, we could
simplify them down to 2:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_gen_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> permissive <span style=font-weight:700>for</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>)
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> <span style=font-weight:700>check</span> ((<span style=font-style:italic>&#39;member_&#39;</span>|| memid = <span style=font-weight:700>current_user</span>) <span style=font-weight:700>and</span> (starttime &gt; now()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_del_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> restrictive <span style=font-weight:700>for</span> <span style=font-weight:700>delete</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (starttime &gt; now());
</span></span></code></pre></div><h2 class=heading id=rls-with-sessionlocal-variables>RLS with Session/Local Variables
<a href=#rls-with-sessionlocal-variables>#</a></h2><p>Now, unless all the members of our club are DB experts and are comfortable
accessing their information directly from Postgres, we&rsquo;ll need some way of
mapping web/app sessions to DB member IDs for RLS authorization.</p><p>One way is to still keep the roles for each member and right before running a
query on behalf of a member, we switch to their role, execute the query, then
switch back to a base role. For example, suppose member 20 wants to book the
Squash Court tomorrow:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>role</span> member_20;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>insert</span> <span style=font-weight:700>into</span> bookings(facid, memid, starttime, slots)
</span></span><span style=display:flex><span><span style=font-weight:700>values</span> (6, 20, now() + <span style=font-style:italic>&#39;1 day&#39;</span>::interval, 4) returning bookid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>reset</span> <span style=font-weight:700>role</span>;
</span></span></code></pre></div><p>Alternatively, we could use session variables and avoid having to create a role
for each member. We&rsquo;ll still keep the <code>member_access</code> role and give it <code>login</code>
privileges:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>role</span> member_access <span style=font-weight:700>with</span> login password <span style=font-style:italic>&#39;123456&#39;</span>;
</span></span></code></pre></div><p>The backend app that connects to Postgres will use <code>member_access</code> exclusively
when handling members&rsquo; interactions with the club&rsquo;s system.</p><p>Let&rsquo;s review PG variables a bit before applying them to RLS.</p><p>Postgres let&rsquo;s us read and write variables:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>set</span> app.foo = <span style=font-style:italic>&#39;bar&#39;</span>;
</span></span></code></pre></div><p>To retrieve the value, we use <code>current_setting</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>select</span> current_setting(<span style=font-style:italic>&#39;app.foo&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>-- bar
</span></span></span></code></pre></div><p>The <code>current_setting</code> function gives us a clue that PG&rsquo;s variable system is
primarily meant for runtime configuration rather than general querying, we&rsquo;re
just being creative with our usage.</p><p>If no value is set for a given variable name, we get an error:</p><pre tabindex=0><code>admin@club=# select current_setting(&#39;app.quz&#39;);
ERROR:  42704: unrecognized configuration parameter &#34;app.quz&#34;
LOCATION:  find_option, guc.c:1278
</code></pre><p><code>current_setting</code> has an optional parameter <code>missing_ok</code> which if set to <code>true</code>,
the error is suppressed and <code>null</code> is returned instead:</p><pre tabindex=0><code>admin@club=# select current_setting(&#39;app.quz&#39;, true);
 current_setting
═════════════════
 ¤
(1 row)

admin@club=# select current_setting(&#39;app.quz&#39;, true) is null;
 ?column?
══════════
 t
(1 row)
</code></pre><p>Variables can also be scoped to transactions via the <code>local</code> keyword. This is
great since it prevents leaking - the variable is cleared after the transaction
and the next query can&rsquo;t access/modify data they weren&rsquo;t supposed to:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>begin</span>;
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>local</span> app.member_name = <span style=font-style:italic>&#39;Alice&#39;</span>;
</span></span><span style=display:flex><span><span style=font-weight:700>select</span> current_setting(<span style=font-style:italic>&#39;app.member_name&#39;</span>, <span style=font-weight:700>true</span>);
</span></span><span style=display:flex><span><span style=font-weight:700>commit</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>select</span> current_setting(<span style=font-style:italic>&#39;app.member_name&#39;</span>, <span style=font-weight:700>true</span>) <span style=font-weight:700>is</span> <span style=font-weight:700>null</span>;
</span></span><span style=display:flex><span><span style=font-style:italic>-- t
</span></span></span></code></pre></div><h3 class=heading id=refactoring-internal-ids--external-ids>Refactoring, Internal IDs & External IDs
<a href=#refactoring-internal-ids--external-ids>#</a></h3><p>Before switching over to local variables, let&rsquo;s make a key change in the schema.
Since member IDs are auto-incrementing primary keys, it&rsquo;s considered best
practice to avoid exposing them in external APIs. Therefore, we&rsquo;ll use UUIDs as
the external member IDs i.e. the ones the rest of the world can &lsquo;see&rsquo;:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> extension <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> <span style=font-weight:700>exists</span> <span style=font-style:italic>&#34;uuid-ossp&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>table</span> cd.members
</span></span><span style=display:flex><span><span style=font-weight:700>add</span> <span style=font-weight:700>column</span> ext_memid uuid <span style=font-weight:700>not</span> <span style=font-weight:700>null</span> <span style=font-weight:700>default</span> uuid_generate_v4();
</span></span></code></pre></div><p>Next, we&rsquo;ll rewrite our policies to use the external IDs rather than the roles.
Let&rsquo;s start with <code>member_read_policy</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>drop</span> policy member_read_policy <span style=font-weight:700>on</span> cd.members;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>create</span> policy member_read_policy <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (
</span></span><span style=display:flex><span>        (ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>        <span style=font-weight:700>or</span>
</span></span><span style=display:flex><span>        (<span style=font-weight:700>select</span> m2.ext_memid = current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>)::uuid
</span></span><span style=display:flex><span>        <span style=font-weight:700>from</span> members m2 <span style=font-weight:700>where</span> m2.memid = recommendedby)
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><h3 class=heading id=rls-infinite-recursion--security-definer-functions>RLS, Infinite Recursion & Security Definer Functions
<a href=#rls-infinite-recursion--security-definer-functions>#</a></h3><p>Though we can create the above policy without any error, if we attempt to run a
select query, we&rsquo;ll get the following error:</p><pre tabindex=0><code>psql:admin.sql:14: ERROR:  42P17: infinite recursion detected in policy for relation &#34;members&#34;
LOCATION:  fireRIRrules, rewriteHandler.c:2247
</code></pre><p>We&rsquo;ve got two basic solution we can apply:</p><ul><li>denormalization</li><li>use a security definer function that sidesteps the RLS check</li></ul><p>With denormalization, we would have to add a <code>recommendedby_xid</code> column:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>begin</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>table</span> cd.members
</span></span><span style=display:flex><span><span style=font-weight:700>add</span> <span style=font-weight:700>column</span> recommendedby_xid uuid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>update</span> cd.members
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> recommendedby_xid = (
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span> ext_memid
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> cd.members mr
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span>  mr.memid = cd.members.recommendedby
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>commit</span>;
</span></span></code></pre></div><p>And then the policy doesn&rsquo;t have to invoke a subquery:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_read_policy <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (
</span></span><span style=display:flex><span>        (ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>        <span style=font-weight:700>or</span>
</span></span><span style=display:flex><span>        (recommendedby_xid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><p>However, let&rsquo;s proceed with the second solution: using a security definer
function. These are functions that execute with the privileges of the owner
(<code>admin</code>) rather than the invoker (<code>member_access</code>). Since <code>admin</code> can bypass
RLS, we won&rsquo;t end up with infinite recursion policy checks. The function is as
follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>or</span> <span style=font-weight:700>replace</span> <span style=font-weight:700>function</span> cd.get_recommender_ext_memid(recommendedby_id integer)
</span></span><span style=display:flex><span><span style=font-weight:700>returns</span> uuid
</span></span><span style=display:flex><span><span style=font-weight:700>language</span> <span style=font-weight:700>sql</span>
</span></span><span style=display:flex><span><span style=font-weight:700>security</span> <span style=font-weight:700>definer</span>
</span></span><span style=display:flex><span><span style=font-weight:700>as</span> <span>$$</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span> ext_memid
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> cd.members
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> memid = recommendedby_id
</span></span><span style=display:flex><span><span>$$</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>function</span> cd.get_recommender_ext_memid(integer) <span style=font-weight:700>owner</span> <span style=font-weight:700>to</span> <span style=font-weight:700>admin</span>;
</span></span><span style=display:flex><span><span style=font-weight:700>grant</span> <span style=font-weight:700>execute</span> <span style=font-weight:700>on</span> <span style=font-weight:700>function</span> cd.get_recommender_ext_memid(integer) <span style=font-weight:700>to</span> member_access;
</span></span></code></pre></div><p>We can now use it in the policy definition:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_read_policy
</span></span><span style=display:flex><span><span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span><span style=font-weight:700>using</span> (
</span></span><span style=display:flex><span>    (ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>    <span style=font-weight:700>or</span>
</span></span><span style=display:flex><span>    (cd.get_recommender_ext_memid(recommendedby) = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 class=heading id=bringing-it-all-together-rls-external-ids-and-local-variables>Bringing It All Together: RLS, External IDs and Local Variables
<a href=#bringing-it-all-together-rls-external-ids-and-local-variables>#</a></h3><p>Let&rsquo;s also update the <code>member_update_policy</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_update_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>update</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid);
</span></span></code></pre></div><p>For some example usage:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>role</span> member_access;
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>local</span> auth.mem_xid = <span style=font-style:italic>&#39;807ea0dc-1361-4536-8837-cc7a0275c14c&#39;</span>; <span style=font-style:italic>-- member 2
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span><span style=font-weight:700>update</span> cd.members
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> telephone = <span style=font-style:italic>&#39;222-222-2222&#39;</span>
</span></span><span style=display:flex><span><span style=font-weight:700>where</span> memid = 2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>select</span> memid, recommendedby, telephone <span style=font-weight:700>from</span> members;
</span></span></code></pre></div><p>We&rsquo;re not quite done yet, we&rsquo;ve also got to handle the policies on the
<code>bookings</code> table. <code>bookings_del_policy</code> will remain as is:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_del_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> restrictive <span style=font-weight:700>for</span> <span style=font-weight:700>delete</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (starttime &gt; now());
</span></span></code></pre></div><p>As for <code>bookings_gen_policy</code>, we&rsquo;ll have to update it.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>drop</span> policy bookings_gen_policy <span style=font-weight:700>on</span> cd.bookings;
</span></span></code></pre></div><p>For the <code>bookings</code> table, we could use a subquery to retrieve the associated
<code>ext_memid</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_gen_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> permissive <span style=font-weight:700>for</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            <span style=font-weight:700>select</span> ext_memid <span style=font-weight:700>from</span> cd.members m
</span></span><span style=display:flex><span>            <span style=font-weight:700>where</span> m.memid = cd.bookings.memid
</span></span><span style=display:flex><span>        ) = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> <span style=font-weight:700>check</span> (
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            <span style=font-weight:700>select</span> ext_memid <span style=font-weight:700>from</span> cd.members m
</span></span><span style=display:flex><span>            <span style=font-weight:700>where</span> m.memid = cd.bookings.memid
</span></span><span style=display:flex><span>        ) = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid
</span></span><span style=display:flex><span>        <span style=font-weight:700>and</span> (starttime &gt; now())
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><p>Or we could opt for denormalization:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>begin</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>table</span> cd.bookings <span style=font-weight:700>add</span> <span style=font-weight:700>column</span> ext_memid UUID;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>update</span> cd.bookings
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> ext_memid = (
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span> ext_memid
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> cd.members
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> cd.members.memid = cd.bookings.memid
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>table</span> cd.bookings <span style=font-weight:700>alter</span> <span style=font-weight:700>column</span> ext_memid <span style=font-weight:700>set</span> <span style=font-weight:700>not</span> <span style=font-weight:700>null</span>;
</span></span><span style=display:flex><span><span style=font-weight:700>commit</span>;
</span></span></code></pre></div><p>Then define the policy as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_gen_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> permissive <span style=font-weight:700>for</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> ( ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> <span style=font-weight:700>check</span> (
</span></span><span style=display:flex><span>        ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid
</span></span><span style=display:flex><span>        <span style=font-weight:700>and</span> (starttime &gt; now())
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><p>I&rsquo;m tempted to go for the denormalization approach but I&rsquo;ll use the former for
now.</p><p>All in all, we end up with the following RLS policies:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_read_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (
</span></span><span style=display:flex><span>        (ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>        <span style=font-weight:700>or</span>
</span></span><span style=display:flex><span>        (cd.get_recommender_ext_memid(recommendedby) = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>create</span> policy member_update_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> cd.members <span style=font-weight:700>for</span> <span style=font-weight:700>update</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_gen_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> permissive <span style=font-weight:700>for</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            <span style=font-weight:700>select</span> ext_memid <span style=font-weight:700>from</span> cd.members m
</span></span><span style=display:flex><span>            <span style=font-weight:700>where</span> m.memid = cd.bookings.memid
</span></span><span style=display:flex><span>        ) = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> <span style=font-weight:700>check</span> (
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            <span style=font-weight:700>select</span> ext_memid <span style=font-weight:700>from</span> cd.members m
</span></span><span style=display:flex><span>            <span style=font-weight:700>where</span> m.memid = cd.bookings.memid
</span></span><span style=display:flex><span>        ) = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid
</span></span><span style=display:flex><span>        <span style=font-weight:700>and</span> (starttime &gt; now())
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>create</span> policy bookings_del_policy <span style=font-weight:700>on</span> cd.bookings
</span></span><span style=display:flex><span>    <span style=font-weight:700>as</span> restrictive <span style=font-weight:700>for</span> <span style=font-weight:700>delete</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (starttime &gt; now());
</span></span></code></pre></div><h2 class=heading id=rls--jwt>RLS & JWT
<a href=#rls--jwt>#</a></h2><p>We now have external IDs that we can expose to the outside world and all our
policies use these IDs for authorization via local variables.</p><p>As an example, suppose we&rsquo;re using JWTs and member 2 has been authenticated and
provided with a token that encodes the following payload:</p><pre tabindex=0><code>{
  &#34;sub&#34;: &#34;807ea0dc-1361-4536-8837-cc7a0275c14c&#34;,
  &#34;exp&#34;: 1735554932
}
</code></pre><p>The <code>sub</code> field holds member 2&rsquo;s external ID.</p><p>With every operation member 2 invokes, they have to send the following token:</p><pre tabindex=0><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI4MDdlYTBkYy0xMzYxLTQ1MzYtODgzNy1jYzdhMDI3NWMxNGMiLCJleHAiOjE3MzU1NTQ5MzJ9.utPHo-Jh4tWnv_2iv7qZYfNJIZ90H5HNGirsIhvTl9o
</code></pre><p>Suppose member 2 wants to retrieve all the bookings she has ever made. Here&rsquo;s
how we&rsquo;d implement the handler in python:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>os</span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>psycopg2</span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>jwt</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>secret_key = os.getenv(<span style=font-style:italic>&#34;JWT_SECRET_KEY&#34;</span>)
</span></span><span style=display:flex><span>pg_url = os.getenv(<span style=font-style:italic>&#34;PG_URL&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>conn = psycopg2.connect(pg_url)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>def</span> get_bookings(conn, token):
</span></span><span style=display:flex><span>    decoded = jwt.decode(token, secret_key, algorithms=[<span style=font-style:italic>&#34;HS256&#34;</span>])
</span></span><span style=display:flex><span>    member_uuid = decoded[<span style=font-style:italic>&#34;sub&#34;</span>]
</span></span><span style=display:flex><span>    bookings = <span style=font-weight:700>None</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>with</span> conn:  <span style=font-style:italic># tx context</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>with</span> conn.cursor() <span style=font-weight:700>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=font-style:italic>&#34;set local auth.mem_xid=</span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#34;</span>, (member_uuid,))
</span></span><span style=display:flex><span>            cur.execute(
</span></span><span style=display:flex><span>                <span style=font-style:italic>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=font-style:italic>                select memid, bookid, f.name, starttime
</span></span></span><span style=display:flex><span><span style=font-style:italic>                from cd.bookings b
</span></span></span><span style=display:flex><span><span style=font-style:italic>                join cd.facilities f using(facid)
</span></span></span><span style=display:flex><span><span style=font-style:italic>                order by starttime desc
</span></span></span><span style=display:flex><span><span style=font-style:italic>            &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            bookings = cur.fetchall()
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> bookings
</span></span></code></pre></div><p>If we push the jwt decoding and validation step into Postgres and switch from
using symmetric keys to asymmetric keys via JSON Web Key Sets (JWKS) then we end
up with something quite close to what Neon provides via
<a href=https://neon.tech/docs/guides/neon-authorize>Neon Authorize</a>.</p><h2 class=heading id=view-permissions-security-invoker-views-and-rls>View Permissions, Security Invoker Views and RLS
<a href=#view-permissions-security-invoker-views-and-rls>#</a></h2><p>Suppose we want to create a view that holds a facilities plus the amount of
money a member spent booking those facilities:</p><p>Suppose we want to create a view that holds each member&rsquo;s sum of payments made
for bookings. We&rsquo;ll do so as admin:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>view</span> member_costs <span style=font-weight:700>as</span>
</span></span><span style=display:flex><span><span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    memid,
</span></span><span style=display:flex><span>    <span style=font-weight:700>sum</span>(f.membercost * b.slots) <span style=font-weight:700>as</span> cost
</span></span><span style=display:flex><span><span style=font-weight:700>from</span> cd.bookings b
</span></span><span style=display:flex><span><span style=font-weight:700>join</span> cd.facilities f <span style=font-weight:700>using</span> (facid)
</span></span><span style=display:flex><span><span style=font-weight:700>group</span> <span style=font-weight:700>by</span> memid
</span></span></code></pre></div><p>We&rsquo;ll also have to grant select to <code>member_access</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>grant</span> <span style=font-weight:700>select</span> <span style=font-weight:700>on</span> member_costs <span style=font-weight:700>to</span> member_access;
</span></span></code></pre></div><p>Let&rsquo;s select from this view as member 2:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>session</span> auth.mem_xid = <span style=font-style:italic>&#39;807ea0dc-1361-4536-8837-cc7a0275c14c&#39;</span>; <span style=font-style:italic>-- member 2
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>select</span> * <span style=font-weight:700>from</span> member_costs;
</span></span></code></pre></div><p>We get:</p><pre tabindex=0><code> memid │  cost
═══════╪═════════
    29 │      70
     4 │  1490.0
     0 │ 30486.0
...
     8 │  3644.0
(30 rows)
</code></pre><p>Not ideal, we&rsquo;re leaking all the other members&rsquo; costs.</p><p>What&rsquo;s happening here is that views have owners (in our case <code>admin</code>) and when
<code>member_access</code> reads from that view, Postgres uses the owner to check what
permissions the view should be evaluated with. <code>admin</code> can bypass RLS therefore
<code>member_access</code> uses the view to effectively bypass RLS.</p><p>Fear not, Postgres provides <code>security_invoker</code> views that ensure the permissions
used to evaluate the views are those of the role accessing the view rather than
the owner. Let&rsquo;s configure it as admin:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>alter</span> <span style=font-weight:700>view</span> member_costs <span style=font-weight:700>set</span> (security_invoker = <span style=font-weight:700>on</span>);
</span></span></code></pre></div><p>Now, if we run the previous query, we only get the authorized member&rsquo;s costs:</p><pre tabindex=0><code>member_access@club=&gt; select * from member_costs;
 memid │ cost
═══════╪═══════
     2 │ 957.0
(1 row)
</code></pre><p>We can also configure <code>security_invoker</code> during the view definition:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>view</span> member_costs
</span></span><span style=display:flex><span><span style=font-weight:700>with</span> (security_invoker=<span style=font-weight:700>true</span>) <span style=font-weight:700>as</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>select</span> memid, <span style=font-weight:700>sum</span>(f.membercost * b.slots) <span style=font-weight:700>as</span> cost
</span></span><span style=display:flex><span>  <span style=font-weight:700>from</span> cd.bookings b
</span></span><span style=display:flex><span>  <span style=font-weight:700>join</span> cd.facilities f <span style=font-weight:700>using</span> (facid)
</span></span><span style=display:flex><span>  <span style=font-weight:700>group</span> <span style=font-weight:700>by</span> memid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>grant</span> <span style=font-weight:700>select</span> <span style=font-weight:700>on</span> member_costs <span style=font-weight:700>to</span> member_access;
</span></span></code></pre></div><p>For more details on security invoker views, check out:</p><ul><li><a href=https://www.postgresql.org/docs/current/rules-views.html>Postgres Docs: Views and the Rule System</a></li><li><a href=https://www.cybertec-postgresql.com/en/view-permissions-and-row-level-security-in-postgresql/>Cybertec: View permissions and row-level security in PostgreSQL - Laurenz Albe</a></li></ul><h2 class=heading id=optimizing-row-level-security>Optimizing Row Level Security
<a href=#optimizing-row-level-security>#</a></h2><p>Let&rsquo;s finish off with one key implementation detail - performance. Granted, our
dataset is currently small and we might cost along without bothering too much
with how long queries take to execute, but it&rsquo;s still worth considering.</p><p>There are two general approaches we can use when optimizing RLS:</p><ul><li>Call functions with select so that the result is cached for the entire query
rather than getting evaluated for each row</li><li>Index columns used for evaluating RLS</li></ul><p>Suppose we revisit our authorization policy for the <code>members</code> table and want to
limit members solely to their own details and cut off access to those of members
they recommended:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-style:italic>-- check to see cd is the first schema in our search_path
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>show</span> search_path;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>-- drop previous policy
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>drop</span> policy member_read_policy <span style=font-weight:700>on</span> members;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>-- drop function to retrieve member uuid since we don&#39;t need it any more as the
</span></span></span><span style=display:flex><span><span style=font-style:italic>-- policy it was being used for is deleted
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>drop</span> <span style=font-weight:700>function</span> get_recommender_ext_memid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>-- add new policy
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>create</span> policy member_read_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> members <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (ext_memid = (current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>))::uuid);
</span></span></code></pre></div><p>Some test data won&rsquo;t hurt, we&rsquo;ll delete it later:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>insert</span> <span style=font-weight:700>into</span> members (memid, surname, firstname, address, zipcode, telephone, joindate)
</span></span><span style=display:flex><span><span style=font-weight:700>with</span> max_id <span style=font-weight:700>as</span> (
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span> coalesce(<span style=font-weight:700>max</span>(memid), 0) <span style=font-weight:700>as</span> max_id <span style=font-weight:700>from</span> members
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    max_id + gs.memid,
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#39;surname_&#39;</span> || gs.memid <span style=font-weight:700>as</span> surname,
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#39;firstname_&#39;</span> || gs.memid <span style=font-weight:700>as</span> firstname,
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#39;address_&#39;</span> || gs.memid <span style=font-weight:700>as</span> address,
</span></span><span style=display:flex><span>    10000 + gs.memid <span style=font-weight:700>as</span> zipcode,
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#39;777&#39;</span> || gs.memid::text <span style=font-weight:700>as</span> telephone,
</span></span><span style=display:flex><span>    now() <span style=font-weight:700>as</span> joindate
</span></span><span style=display:flex><span><span style=font-weight:700>from</span>
</span></span><span style=display:flex><span>    max_id, generate_series(1, 250000) <span style=font-weight:700>as</span> gs(memid);
</span></span></code></pre></div><p>Let&rsquo;s run the following query as <code>member_access</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>session</span> auth.mem_xid = <span style=font-style:italic>&#39;807ea0dc-1361-4536-8837-cc7a0275c14c&#39;</span>; <span style=font-style:italic>-- member 2
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>explain</span> (<span style=font-weight:700>analyze</span>, buffers)
</span></span><span style=display:flex><span>  <span style=font-weight:700>select</span> memid, firstname, surname <span style=font-weight:700>from</span> members;
</span></span></code></pre></div><p>This query has the following plan:</p><pre tabindex=0><code>                                                      QUERY PLAN
═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
 Gather  (cost=1000.00..11077.69 rows=1 width=34) (actual time=0.239..53.892 rows=1 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   Buffers: shared hit=7994
   -&gt;  Parallel Seq Scan on members  (cost=0.00..10077.59 rows=1 width=34) (actual time=31.565..48.504 rows=0 loops=3)
         Filter: (ext_memid = (current_setting(&#39;auth.mem_xid&#39;::text, true))::uuid)
         Rows Removed by Filter: 83343
         Buffers: shared hit=7994
 Planning Time: 0.085 ms
 Execution Time: 53.913 ms
</code></pre><p>Let&rsquo;s apply both optimization strategies. First, notice that the
<code>current_setting</code> is being invoked for each row. If we rewrite the policy as
follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> policy member_read_policy
</span></span><span style=display:flex><span>    <span style=font-weight:700>on</span> members <span style=font-weight:700>for</span> <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>using</span> (ext_memid = (<span style=font-weight:700>select</span> current_setting(<span style=font-style:italic>&#39;auth.mem_xid&#39;</span>, <span style=font-weight:700>true</span>)::uuid));
</span></span></code></pre></div><p>then we get the following plan:</p><pre tabindex=0><code>                                                     QUERY PLAN
════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
 Gather  (cost=1000.02..10296.36 rows=1 width=34) (actual time=0.355..14.570 rows=1 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   Buffers: shared hit=7994
   InitPlan 1
     -&gt;  Result  (cost=0.00..0.02 rows=1 width=16) (actual time=0.003..0.004 rows=1 loops=1)
   -&gt;  Parallel Seq Scan on members  (cost=0.00..9296.24 rows=1 width=34) (actual time=5.505..9.372 rows=0 loops=3)
         Filter: (ext_memid = (InitPlan 1).col1)
         Rows Removed by Filter: 83343
         Buffers: shared hit=7994
 Planning:
   Buffers: shared hit=5
 Planning Time: 0.090 ms
 Execution Time: 14.591 ms
</code></pre><p>Notice that we&rsquo;re caching the invocation of <code>current_setting</code> in <code>InitPlan 1</code>
and its conversion from <code>text</code> to <code>uuid</code>. This gives us a speed up of 3.69.</p><p>We&rsquo;ve still got the sequential scan. Let&rsquo;s add an index on the <code>ext_memid</code>
column which we&rsquo;re using for RLS:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>index</span> idx_members_ext_memid <span style=font-weight:700>on</span> members(ext_memid);
</span></span></code></pre></div><p>We now get the following plan:</p><pre tabindex=0><code>                                                           QUERY PLAN
════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
 Index Scan using idx_members_ext_memid on members  (cost=0.44..8.46 rows=1 width=34) (actual time=0.108..0.111 rows=1 loops=1)
   Index Cond: (ext_memid = (InitPlan 1).col1)
   Buffers: shared hit=1 read=3
   InitPlan 1
     -&gt;  Result  (cost=0.00..0.02 rows=1 width=16) (actual time=0.010..0.011 rows=1 loops=1)
 Planning:
   Buffers: shared hit=16 read=1
 Planning Time: 0.620 ms
 Execution Time: 0.158 ms
</code></pre><p>Not bad (it&rsquo;s now 340x faster). Reviewing and optimizing all the other policies
is left as an exercise for the reader. That&rsquo;s all for Row Level Security - if
there&rsquo;s something I missed please do reach out.</p><h2 class=heading id=references>References
<a href=#references>#</a></h2><ol><li><a href=https://www.postgresql.org/docs/current/ddl-rowsecurity.html>PG Docs: Row Security Policies</a></li><li><a href=https://www.postgresql.org/docs/current/sql-createpolicy.html>PG Docs: Create Policy</a></li><li><a href=https://satoricyber.com/postgres-security/postgres-row-level-security/>Row Level Security (RLS): Basics and Examples - Satori</a></li><li><a href=https://www.crunchydata.com/blog/row-level-security-for-tenants-in-postgres>Row Level Security for Tenants in Postgres - Craig Kerstiens - Crunchy Data</a></li><li><a href=https://pgdash.io/blog/exploring-row-level-security-in-postgres.html>Exploring Row Level Security in PostgreSQL - pgDash</a></li><li><a href=https://maxlynch.com/2023/11/04/tips-for-row-level-security-rls-in-postgres-and-supabase/>Tips for Row Level Security (RLS) in Postgres and
Supabase</a></li><li><a href=https://supabase.com/docs/guides/database/postgres/row-level-security>Row Level Security - Supabase</a></li></ol></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-next></div><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text><a href=/blog/pg-multitenancy-models/>Multi-Tenancy Models in PostgreSQL</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>&mldr;</p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>